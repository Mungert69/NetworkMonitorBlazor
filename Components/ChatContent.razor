@page "/chat"
@using NetworkMonitorBlazor.Services
@using NetworkMonitorBlazor.Models
@inject ChatStateService ChatState
@inject IJSRuntime JSRuntime
@inject WebSocketService WebSocketService
@inject AudioService AudioService
@inject LLMService LLMService
@inject ChatStateService ChatState

<div class="chat-container" style="@GetChatStyles()">
    <div class="chat-card">
        @if (!string.IsNullOrEmpty(ChatState.LoadWarning))
        {
            <div class="load-warning">
                @((MarkupString)ChatState.LoadWarning)
            </div>
        }

        <!-- Header Section -->
        <div class="chat-header">
            <div class="header-title">
                Network Monitor Assistant (@ChatState.LLMRunnerType)
            </div>
            <div class="header-actions">
                <!-- Left-Aligned Icons -->
                <div class="action-buttons-left">
                    <button @onclick="SaveFeedback" disabled="@(!ChatState.IsReady)">
                        <SaveIcon />
                        <span class="tooltip">Save</span>
                    </button>
                    
                    <button @onclick="ToggleLLMRunnerType" disabled="@ChatState.IsToggleDisabled">
                        <SwapHorizIcon />
                        <span class="tooltip">Toggle LLM Type</span>
                    </button>
                    
                    @if (!ChatState.IsDrawerOpen)
                    {
                        <button @onclick="() => ChatState.IsDrawerOpen = true" disabled="@(!ChatState.IsReady)">
                            <KeyboardArrowUpIcon />
                            <span class="tooltip">Open Links</span>
                        </button>
                    }
                    
                    <button @onclick="ToggleExpand">
                        @if (ChatState.IsExpanded)
                        {
                            <FullscreenExitIcon />
                            <span class="tooltip">Contract</span>
                        }
                        else
                        {
                            <FullscreenIcon />
                            <span class="tooltip">Expand</span>
                        }
                    </button>
                    
                    <button @onclick="ResetSessionId" class="warning-button">
                        <RefreshIcon />
                        <span class="tooltip">Start New Chat</span>
                    </button>
                    
                    <button @onclick="ToggleAudio">
                        @if (ChatState.IsMuted)
                        {
                            <VolumeOffIcon />
                            <span class="tooltip">Unmute Audio</span>
                        }
                        else
                        {
                            <VolumeUpIcon />
                            <span class="tooltip">Mute Audio</span>
                        }
                    </button>
                </div>
                
                <!-- Right-Aligned Icons -->
                <div class="action-buttons-right">
                    <button @onclick="ToggleHistory" @ref="historyButtonRef">
                        <HistoryIcon />
                        <span class="tooltip">History</span>
                    </button>
                    
                    <button @onclick="CloseChat">
                        <CloseIcon />
                        <span class="tooltip">Hide Assistant</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Chat Content -->
        <div class="chat-messages" 
             @ref="outputContainerRef"
             @onmouseenter="() => ChatState.IsHoveringMessages = true"
             @onmouseleave="() => ChatState.IsHoveringMessages = false">
            
            @if (!ChatState.IsReady)
            {
                <div class="loading-indicator">
                    <div class="spinner"></div>
                </div>
            }
            else
            {
                @((MarkupString)RenderContent(ChatState.LLMFeedback))
            }
            
            @if (ChatState.IsProcessing && !ChatState.IsLLMBusy)
            {
                <div class="thinking-dots">Thinking@(ChatState.ThinkingDots)</div>
            }
            
            @if (ChatState.IsCallingFunction)
            {
                <div class="function-call-message">@ChatState.CallingFunctionMessage</div>
            }
            
            @if (ChatState.ShowHelpMessage && !IsDashboard)
            {
                <div class="help-message">@ChatState.HelpMessage</div>
            }
        </div>

        <!-- Links Drawer -->
        <div class="drawer @(ChatState.IsDrawerOpen ? "open" : "")">
            <div class="drawer-content">
                @RenderLinks()
            </div>
        </div>

        <!-- History Popper -->
        @if (IsHistoryOpen)
        {
            <div class="history-popper">
                <HistoryList Histories="ChatState.Histories" 
                            OnSelectSession="HandleSelectSession" 
                            OnDeleteSession="HandleDeleteSession" 
                            LLMType="ChatState.LLMRunnerType" 
                            CurrentSessionId="ChatState.SessionId" />
            </div>
        }

        <!-- Chat Input -->
        <div class="chat-input">
            <div class="input-container">
                <textarea @bind="ChatState.CurrentMessage"
                          @bind:event="oninput"
                          @onfocus="() => ChatState.IsInputFocused = true"
                          @onblur="() => ChatState.IsInputFocused = false"
                          placeholder="Type a message..."
                          maxlength="10000"
                          @onkeydown="HandleKeyDown"></textarea>
                
                <div class="input-buttons">
                    <button @onclick="SendMessage" disabled="@(ChatState.IsLLMBusy || !ChatState.IsReady)">
                        <SendIcon />
                        <span class="tooltip">Send Message</span>
                    </button>
                    
                    <button @onclick="ToggleRecording" disabled="@ChatState.IsProcessing">
                        @if (IsRecording)
                        {
                            <MicOffIcon />
                            <span class="tooltip">Stop Recording</span>
                        }
                        else
                        {
                            <MicIcon />
                            <span class="tooltip">Start Recording</span>
                        }
                    </button>
                    
                    <button @onclick="StopLLM" disabled="@(!ChatState.IsLLMBusy || !ChatState.IsReady)" class="warning-button">
                        <StopIcon />
                        <span class="tooltip">Halt Assistant</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<MessageDisplay Message="ChatState.Message" />

@code {
    private ElementReference outputContainerRef;
    private ElementReference historyButtonRef;
    private bool IsHistoryOpen = false;
    private bool IsRecording = false;

    [Parameter]
    public EventCallback<HostLink> OnHostLinkClick { get; set; }

    [Parameter]
    public bool IsDashboard { get; set; }

    [Parameter]
    public string InitRunnerType { get; set; } = "TurboLLM";

    [Parameter]
    public EventCallback<bool> SetIsChatOpen { get; set; }

    [Parameter]
    public string SiteId { get; set; }="";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await ChatState.Initialize(InitRunnerType);
        
        // THEN initialize WebSocket with BOTH parameters
        await WebSocketService.Initialize(SiteId, ChatState.SessionId);
        }

        if (ChatState.AutoScrollEnabled)
        {
            //await JSRuntime.InvokeVoidAsync("scrollToBottom", outputContainerRef);
        }
    }

    private async Task ResetSessionId()
{
    await WebSocketService.SendMessage("<|REMOVE_SESSION|>");
    Console.WriteLine("Message sent: <|REMOVE_SESSION|>");

    await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "sessionId");
    await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "sessionTimestamp");

    var newSessionId = Guid.NewGuid().ToString();
    await JSRuntime.InvokeVoidAsync("localStorage.setItem", "sessionId", newSessionId);
    await JSRuntime.InvokeVoidAsync("localStorage.setItem", "sessionTimestamp", DateTime.Now.Ticks.ToString());
    ChatState.SessionId = newSessionId;
}

    private string GetChatStyles()
    {
        if (ChatState.IsExpanded)
        {
            return "position: fixed; top: 70px; left: 64px; right: 20px; bottom: 20px; width: calc(100% - 84px); height: calc(100% - 90px); max-height: none;";
        }
        else
        {
            return "position: fixed; bottom: 20px; right: 20px; width: 320px; height: calc(100% - 90px); max-height: none;";
        }
    }

    private async Task ProcessAudioBlob(byte[] audioBlob)
    {
        try
        {
            ChatState.IsProcessing = true;
            StateHasChanged();

            var transcription = await AudioService.TranscribeAudio(audioBlob);

            if (!string.IsNullOrEmpty(transcription))
            {
                Console.WriteLine($"Transcription: {transcription}");
                await SendTranscription(transcription);
            }
            else
            {
                await JSRuntime.InvokeVoidAsync("alert", "Failed to transcribe audio.");
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error processing audio blob: {ex}");
            await JSRuntime.InvokeVoidAsync("alert", "Error processing audio.");
        }
        finally
        {
            ChatState.IsProcessing = false;
            StateHasChanged();
        }
    }

    private async Task SendTranscription(string transcription)
    {
        await AudioService.ClearQueue();
        ChatState.IsProcessing = true;
        await WebSocketService.SendMessage(transcription);
        ChatState.CurrentMessage = "";
        StateHasChanged();
    }

    private async Task HandleStartRecording()
    {
        await AudioService.PauseAudio();
        IsRecording = true;
        // Start recording logic using JS interop
        await JSRuntime.InvokeVoidAsync("startRecording");
    }

    private async Task HandleStopRecording()
    {
        IsRecording = false;
        // Stop recording logic using JS interop
        var audioBlob = await JSRuntime.InvokeAsync<byte[]>("stopRecording");
        await ProcessAudioBlob(audioBlob);
    }

    private void ToggleRecording()
    {
        if (IsRecording)
        {
            HandleStopRecording();
        }
        else
        {
            HandleStartRecording();
        }
    }

    private void CloseExpand()
    {
        ChatState.IsExpanded = false;
    }

    private async Task ToggleAudio()
    {
        if (ChatState.IsMuted)
        {
            Console.WriteLine("Unmuting audio...");
            ChatState.IsMuted = false;
            await WebSocketService.SendMessage("<|START_AUDIO|>");
        }
        else
        {
            Console.WriteLine("Muting audio...");
            await AudioService.ClearQueue();
            ChatState.IsMuted = true;
            await WebSocketService.SendMessage("<|STOP_AUDIO|>");
        }
    }

    private async Task HandleSelectSession(string selectedSessionId)
    {
        ChatState.SessionId = selectedSessionId;
        ChatState.OpenMessage = "<|REPLAY_HISTORY|>";
        await ResetLLM();
    }

    private async Task HandleDeleteSession(string fullSessionId)
    {
        var message = "<|REMOVE_SAVED_SESSION|>" + fullSessionId;
        await WebSocketService.SendMessage(message);
    }

    private void ToggleLLMRunnerType()
    {
        if (ChatState.IsToggleDisabled) return;
        ChatState.OpenMessage = "<|REPLAY_HISTORY|>";
        ChatState.IsToggleDisabled = true;

        var types = LLMService.GetLLMTypes();
        var currentIndex = types.IndexOf(ChatState.LLMRunnerTypeRef);
        var nextIndex = (currentIndex + 1) % types.Count;
        ChatState.LLMRunnerTypeRef = types[nextIndex];
        ChatState.LLMRunnerType = types[nextIndex];
    }

    private void ToggleExpand()
    {
        ChatState.IsExpanded = !ChatState.IsExpanded;
    }

    private void ToggleDrawer(bool open)
    {
        ChatState.IsDrawerOpen = open;
    }

    private async Task SaveFeedback()
    {
        await JSRuntime.InvokeVoidAsync("downloadFile", "AssistantOutput.txt", ChatState.LLMFeedback);
    }

    private async Task SendMessage()
    {
        await AudioService.ClearQueue();
        ChatState.IsProcessing = true;
        await WebSocketService.SendMessage(ChatState.CurrentMessage);
        ChatState.CurrentMessage = "";
    }

  private async Task HandleKeyDown(KeyboardEventArgs e)
{
    if (e.Key == "Enter" && !e.ShiftKey)
    {
        // Remove e.PreventDefault();
        await SendMessage();
    }
}

    private async Task StopLLM()
    {
        await WebSocketService.SendMessage("<|STOP_LLM|>");
        Console.WriteLine("Message sent: <|STOP_LLM|>");
    }

    private async Task ResetLLM()
    {
        await WebSocketService.SendMessage("<|REMOVE_SESSION|>");
        Console.WriteLine("Message sent: <|REMOVE_SESSION|>");

        await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "sessionId");
        await JSRuntime.InvokeVoidAsync("localStorage.removeItem", "sessionTimestamp");

        var newSessionId = Guid.NewGuid().ToString();
        await JSRuntime.InvokeVoidAsync("localStorage.setItem", "sessionId", newSessionId);
        await JSRuntime.InvokeVoidAsync("localStorage.setItem", "sessionTimestamp", DateTime.Now.Ticks.ToString());
        ChatState.SessionId = newSessionId;
    }

    private void ToggleHistory()
    {
        IsHistoryOpen = !IsHistoryOpen;
    }

    private void CloseChat()
    {
        SetIsChatOpen.InvokeAsync(false);
        IsHistoryOpen = false;
    }

    private RenderFragment RenderLinks()
    {
        if (ChatState.LinkData == null || ChatState.LinkData.Count == 0) return null;

        return @<ul class="link-list">
            @foreach (var linkItem in ChatState.LinkData)
            {
                <li>
                    <button @onclick="(() => { CloseExpand(); OnHostLinkClick.InvokeAsync(linkItem); })" class="link-button">
                        @if (!string.IsNullOrEmpty(linkItem.DateStarted))
                        {
                            @($"{linkItem.Address} : {linkItem.DateStarted}")
                        }
                        else
                        {
                            @linkItem.Address
                        }
                    </button>
                </li>
            }
        </ul>;
    }

    private string RenderContent(string content)
    {
        // Split content while preserving message markers
        var messageBlocks = new List<(string Type, string Content)>();
        var markers = new[] { "<User:>", "<Assistant:>", "<Function Call:>", "<Function Response:>" };
        var currentBlock = (Type: "text", Content: "");

        var parts = content.Split(markers, StringSplitOptions.None);

        foreach (var part in parts)
        {
            if (markers.Contains(part))
            {
                if (!string.IsNullOrWhiteSpace(currentBlock.Content) || currentBlock.Content.Contains('\n'))
                {
                    messageBlocks.Add(currentBlock);
                }
                currentBlock = (Type: part.Replace("<", "").Replace(">", "").Replace(":", "").Trim(), Content: "");
            }
            else if (!string.IsNullOrEmpty(part))
            {
                currentBlock.Content += part;
            }
        }

        if (!string.IsNullOrWhiteSpace(currentBlock.Content) || currentBlock.Content.Contains('\n'))
        {
            messageBlocks.Add(currentBlock);
        }

        var result = new System.Text.StringBuilder();
        foreach (var block in messageBlocks)
        {
            if (block.Type == "text")
            {
                result.Append(MarkdownRenderer.ToHtml(block.Content));
            }
            else
            {
                result.Append($"<div class='message-line {block.Type.ToLower()}'>");
                result.Append(block.Content.Replace("\\`", "`"));
                result.Append("</div>");
            }
        }

        return result.ToString();
    }
}
